<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NEON SURVIVOR</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at center, #0f172a, #020617);
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body class="text-white select-none">

<div class="fixed top-4 left-4 z-10 text-sm">
  <div class="font-bold text-cyan-400">NEON SURVIVOR</div>
  <div>Time: <span id="time">0.0</span>s</div>
  <div>Dash: <span id="dash">READY</span></div>
</div>

<div id="gameOver" class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-20">
  <div class="text-center space-y-4 animate-pulse">
    <div class="text-4xl font-extrabold text-red-400">GAME OVER</div>
    <div class="text-lg">Survived <span id="finalTime"></span>s</div>
    <div class="text-sm opacity-70">Refresh to retry</div>
  </div>
</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const timeEl = document.getElementById("time");
const dashEl = document.getElementById("dash");
const gameOverEl = document.getElementById("gameOver");
const finalTimeEl = document.getElementById("finalTime");

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

let t0 = performance.now();
let alive = true;
let shake = 0;

const player = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  r: 8,
  dash: 0
};

const enemies = [];
const particles = [];

function spawnEnemy() {
  const angle = Math.random() * Math.PI * 2;
  enemies.push({
    angle,
    speed: 0.5 + Math.random() * 1.5,
    radius: Math.max(canvas.width, canvas.height),
    thickness: 6 + Math.random() * 10
  });
}

setInterval(spawnEnemy, 900);

addEventListener("mousemove", e => {
  player.x = e.clientX;
  player.y = e.clientY;
});

addEventListener("keydown", e => {
  if (e.code === "Space" && player.dash <= 0) {
    player.dash = 120;
    shake = 12;
    for (let i = 0; i < 20; i++) {
      particles.push({
        x: player.x,
        y: player.y,
        vx: Math.cos(i) * Math.random() * 6,
        vy: Math.sin(i) * Math.random() * 6,
        life: 30
      });
    }
  }
});

function update(dt) {
  if (!alive) return;

  player.dash -= dt * 60;

  enemies.forEach(e => {
    e.angle += e.speed * dt * 0.5;
    e.radius -= dt * 80;
  });

  for (let e of enemies) {
    const x = canvas.width / 2 + Math.cos(e.angle) * e.radius;
    const y = canvas.height / 2 + Math.sin(e.angle) * e.radius;
    const d = Math.hypot(x - player.x, y - player.y);
    if (d < e.thickness + player.r && player.dash <= 0) {
      alive = false;
      finalTimeEl.textContent = ((performance.now() - t0) / 1000).toFixed(2);
      gameOverEl.classList.remove("hidden");
    }
  }

  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
  });

  particles.splice(0, particles.filter(p => p.life > 0).length);

  dashEl.textContent = player.dash > 0 ? "COOLDOWN" : "READY";
}

function draw() {
  ctx.save();
  if (shake > 0) {
    ctx.translate(
      (Math.random() - 0.5) * shake,
      (Math.random() - 0.5) * shake
    );
    shake *= 0.9;
  }

  ctx.fillStyle = "rgba(2,6,23,0.4)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  enemies.forEach(e => {
    ctx.strokeStyle = "rgba(34,211,238,0.8)";
    ctx.lineWidth = e.thickness;
    ctx.beginPath();
    ctx.arc(
      canvas.width / 2,
      canvas.height / 2,
      e.radius,
      e.angle,
      e.angle + Math.PI / 2
    );
    ctx.stroke();
  });

  ctx.fillStyle = "white";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fill();

  particles.forEach(p => {
    ctx.fillStyle = `rgba(34,211,238,${p.life / 30})`;
    ctx.fillRect(p.x, p.y, 2, 2);
  });

  ctx.restore();
}

let last = performance.now();
function loop(now) {
  const dt = (now - last) / 1000;
  last = now;

  update(dt);
  draw();

  if (alive) {
    timeEl.textContent = ((now - t0) / 1000).toFixed(1);
    requestAnimationFrame(loop);
  }
}
loop(last);
</script>
</body>
</html>
